#version 330 core
layout (location = 0) out vec3 gPosition;
layout (location = 1) out vec3 gNormal;
layout (location = 2) out vec4 gAlbedo;
layout (location = 3) out vec4 gLightmap;
layout (location = 4) out vec3 gViewDir;

in vec3 FragPos;
in vec3 color;
in vec3 TexCoord;
in vec3 surfaceNormal;
in vec3 TangentViewPos;
in vec3 TangentFragPos;

struct Material {
	samplerCube diffuseTexture; // texture sampler
	samplerCube lightmap;
	bool existsLightmap;
	samplerCube normalmap;
	bool existsNormalmap;
	samplerCube displacementmap;
	bool existsDisplacementmap;
	float shininess;
};
uniform Material material;

uniform int userMode;

uniform vec3 viewPos;

const float heightScale = 0.015;

void main()
{
	vec3 tempTextCoord = normalize(TexCoord);
	vec3 displacedTextCoord = tempTextCoord;
	// if (material.existsDisplacementmap) {
	// 	vec3 tangentViewDir = normalize(TangentViewPos - TangentFragPos);
	// 	displacedTextCoord = vec3(DisplacementMapping(tempTextCoord, tangentViewDir), tempTextCoord.z);
	// }

	vec4 diffuse = texture(material.diffuseTexture, TexCoord);

	gAlbedo.rgb = diffuse.rgb;
	gAlbedo.a = 1.0;

	gViewDir = normalize(viewPos - FragPos);

	// store the fragment position vector in the first gbuffer texture
	gPosition = FragPos;

	if (!material.existsNormalmap && !material.existsDisplacementmap) {
		// also store the per-fragment normals into the gbuffer
		gNormal = normalize(surfaceNormal);
	}else {
		// obtain normal from normal map in range [0,1]
		vec3 normal = texture(material.normalmap, displacedTextCoord).rgb;
		// transform normal vector to range [-1,1]
		normal = normalize(normal * 2.0 - 1.0);
		gNormal = normal;
	}

	// and the lightmap per-fragment color
	if (material.existsLightmap) {
		gLightmap.rgb = texture(material.lightmap, displacedTextCoord).rgb;
	}else {
		gLightmap = vec4(1.0, 1.0, 1.0, 1.0);
	}

}